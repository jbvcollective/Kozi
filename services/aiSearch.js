/**
 * AI Search service: intent classification via Gemini + Supabase query builder.
 * No SQL is ever generated by AI; filters are validated and applied safely.
 */

const GEMINI_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent";
const MAX_QUERY_LENGTH = 500;
const MAX_RESULTS = 25;
const MAX_PRICE = 1e10;
const MIN_PRICE = 0;
const MAX_BEDS_BATHS = 20;
const ALLOWED_PROPERTY_TYPES = ["detached", "semi-detached", "condo", "townhouse", "commercial", "land", "multi-family", "apartment", "house"];
const ALLOWED_INTENTS = ["search", "market_info", "real_estate_question", "clarification_needed"];

function getGeminiClient() {
  const key = process.env.GEMINI_API_KEY;
  return key ? { key, url: GEMINI_URL } : null;
}

function sanitizeStr(input, maxLen = 200) {
  if (input == null || typeof input !== "string") return null;
  const s = input.replace(/[\x00-\x1f\x7f]/g, "").trim().slice(0, maxLen);
  return s || null;
}

function sanitizeNum(value, min, max) {
  if (value == null) return null;
  const n = Number(value);
  if (!Number.isFinite(n)) return null;
  const clamped = Math.max(min, Math.min(max, Math.floor(n)));
  return clamped;
}

/**
 * Call Gemini to classify intent and extract structured data. Returns strict JSON only.
 */
export async function classifyIntent(query) {
  const client = getGeminiClient();
  if (!client) return { error: "AI not configured" };

  const q = sanitizeStr(query, MAX_QUERY_LENGTH);
  if (!q) return { error: "Missing query" };

  const systemPrompt = `You are a real estate assistant. Classify the user message into exactly one intent and return ONLY valid JSON with no markdown, no explanation, no SQL.

INTENTS:
- "search": User wants to find listings (homes, condos, price, location, beds, features, etc.)
- "market_info": User asks about market stats (average price, good time to buy, market trends, what's happening in X)
- "real_estate_question": User asks a factual question (closing costs, land transfer tax, explain something in Ontario/Canada)
- "clarification_needed": Query is vague ("cheap homes", "nice family homes", "good neighborhood") and needs a follow-up question

OUTPUT FORMAT (return ONLY one of these):

If intent = "search", return:
{"intent":"search","filters":{"city":string|null,"max_price":number|null,"min_price":number|null,"bedrooms":number|null,"bathrooms":number|null,"property_type":string|null,"features":string[],"keywords":string[],"year_built_min":number|null}}

If intent = "market_info", return:
{"intent":"market_info","topic":string,"city":string|null}

If intent = "real_estate_question", return:
{"intent":"real_estate_question","question":string}

If intent = "clarification_needed", return:
{"intent":"clarification_needed","question":string}

RULES:
- city: one city/region (e.g. Toronto, Mississauga, GTA). null if not mentioned.
- max_price/min_price: numbers only. "under 800k" -> max_price 800000. "over 500k" -> min_price 500000.
- bedrooms/bathrooms: integer. "3 bedroom" -> 3.
- property_type: one of detached, semi-detached, condo, townhouse, commercial, house, apartment. "home" -> house. null if not specified.
- features: array of strings (e.g. ["gym","parking","pool","finished basement"]). Empty array if none.
- keywords: array of strings for free text (e.g. ["Square One","investment"]). Empty array if none.
- year_built_min: number or null. "built after 2015" -> 2015.
- topic: short topic for market_info (e.g. "average price", "market trends").
- question: the user's question or a short follow-up for clarification_needed.

Return the JSON object only.`;

  try {
    const res = await fetch(`${client.url}?key=${client.key}`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        contents: [{ role: "user", parts: [{ text: `${systemPrompt}\n\nUser message: ${q}` }] }],
        generationConfig: { temperature: 0.05, maxOutputTokens: 512 },
      }),
    });
    if (!res.ok) return { error: "Classification failed" };
    const data = await res.json();
    const text = data?.candidates?.[0]?.content?.parts?.[0]?.text?.trim();
    if (!text) return { error: "No response" };
    const cleaned = text.replace(/^```json?\s*|\s*```$/g, "").trim();
    const parsed = JSON.parse(cleaned);
    if (!ALLOWED_INTENTS.includes(parsed.intent)) return { error: "Invalid intent" };
    return { data: parsed };
  } catch (e) {
    return { error: e.message || "Classification failed" };
  }
}

/**
 * Build and run Supabase query from validated filters. Returns { count, listings } or error.
 */
export async function runSearch(supabase, filters, authUserId) {
  const LISTINGS_SELECT = "listing_key, idx, vow, updated_at";
  const limit = Math.min(MAX_RESULTS, 25);

  const city = sanitizeStr(filters?.city, 100);
  const maxPrice = sanitizeNum(filters?.max_price, MIN_PRICE, MAX_PRICE);
  const minPrice = sanitizeNum(filters?.min_price, MIN_PRICE, MAX_PRICE);
  const bedrooms = sanitizeNum(filters?.bedrooms, 0, MAX_BEDS_BATHS);
  const bathrooms = sanitizeNum(filters?.bathrooms, 0, MAX_BEDS_BATHS);
  let propertyType = filters?.property_type;
  if (propertyType != null && typeof propertyType === "string") {
    propertyType = propertyType.trim().toLowerCase();
    if (!ALLOWED_PROPERTY_TYPES.includes(propertyType)) propertyType = null;
  } else propertyType = null;
  const yearBuiltMin = sanitizeNum(filters?.year_built_min, 1900, 2030);
  const features = Array.isArray(filters?.features) ? filters.features.filter((f) => typeof f === "string").map((s) => s.slice(0, 50)) : [];
  const keywords = Array.isArray(filters?.keywords) ? filters.keywords.filter((k) => typeof k === "string").map((s) => s.slice(0, 80)) : [];

  // Build base query. PostgREST JSONB: use filter('idx->>Key', op, value). Fetch slightly more if we filter in-memory.
  const fetchLimit = (keywords.length || features.length) ? Math.min(200, limit * 4) : limit;
  let query = supabase
    .from("listings_unified_clean")
    .select(LISTINGS_SELECT, { count: "exact" })
    .order("updated_at", { ascending: false })
    .limit(fetchLimit);

  if (city) query = query.ilike("idx->>City", `%${city}%`);
  if (maxPrice != null) query = query.filter("idx->ListPrice", "lte", maxPrice);
  if (minPrice != null) query = query.filter("idx->ListPrice", "gte", minPrice);
  if (bedrooms != null) query = query.gte("idx->BedroomsTotal", bedrooms);
  if (bathrooms != null) query = query.gte("idx->BathroomsTotalInteger", bathrooms);
  if (propertyType) query = query.ilike("idx->>PropertyType", `%${propertyType}%`);
  if (yearBuiltMin != null) query = query.gte("idx->YearBuilt", yearBuiltMin);

  const { data: rows, error, count } = await query;
  if (error) return { error: error.message };

  let list = rows || [];
  if (keywords.length > 0 || features.length > 0) {
    const lowerK = keywords.map((k) => k.toLowerCase());
    const lowerF = features.map((f) => f.toLowerCase());
    list = list.filter((row) => {
      const idx = row.idx || {};
      const text = [idx.PublicRemarks, idx.StreetName, idx.Features, idx.ExteriorFeatures].filter(Boolean).join(" ").toLowerCase();
      if (lowerK.length && !lowerK.some((k) => text.includes(k))) return false;
      if (lowerF.length && !lowerF.some((f) => text.includes(f))) return false;
      return true;
    });
  }

  const finalList = list.slice(0, limit);
  return { count: (keywords.length || features.length) ? finalList.length : (count ?? list.length), listings: finalList };
}

/**
 * Answer a real estate question using Gemini (Ontario-specific).
 */
export async function answerRealEstateQuestion(question) {
  const client = getGeminiClient();
  if (!client) return { error: "AI not configured" };
  const q = sanitizeStr(question, 300);
  if (!q) return { error: "Missing question" };
  try {
    const res = await fetch(`${client.url}?key=${client.key}`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        contents: [{
          role: "user",
          parts: [{
            text: `You are a licensed Canadian real estate assistant. Provide accurate, Ontario-specific answers. Keep answers concise (2-4 short paragraphs). No SQL, no code.\n\nQuestion: ${q}`,
          }],
        }],
        generationConfig: { temperature: 0.3, maxOutputTokens: 1024 },
      }),
    });
    if (!res.ok) return { error: "Answer failed" };
    const data = await res.json();
    const text = data?.candidates?.[0]?.content?.parts?.[0]?.text?.trim();
    return text ? { answer: text } : { error: "No answer" };
  } catch (e) {
    return { error: e.message || "Answer failed" };
  }
}

/**
 * Market info: try analytics or Gemini summary.
 */
export async function getMarketInfo(supabase, topic, city) {
  const t = sanitizeStr(topic, 100);
  const c = sanitizeStr(city, 100);
  try {
    const { data: areaHealth } = await supabase
      .from("analytics_area_market_health")
      .select("*")
      .limit(5);
    const { data: monthly } = await supabase
      .from("analytics_monthly")
      .select("year_month, median_sold_price, active_count, sold_count")
      .order("year_month", { ascending: false })
      .limit(12);
    const client = getGeminiClient();
    if (client && (areaHealth?.length || monthly?.length)) {
      const res = await fetch(`${client.url}?key=${client.key}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          contents: [{
            role: "user",
            parts: [{
              text: `You are a Canadian real estate analyst. Based on this data, give a 2-3 sentence market summary. Topic: ${t}. City/area: ${c || "general"}. Data - area_health: ${JSON.stringify(areaHealth || [])}. Monthly: ${JSON.stringify(monthly || [])}. No SQL, no code.`,
            }],
          }],
          generationConfig: { temperature: 0.3, maxOutputTokens: 512 },
        }),
      });
      if (res.ok) {
        const data = await res.json();
        const text = data?.candidates?.[0]?.content?.parts?.[0]?.text?.trim();
        if (text) return { answer: text };
      }
    }
    if (getGeminiClient()) {
      const ans = await answerRealEstateQuestion(`What is happening in the ${c || "Canadian"} real estate market? ${t}`);
      if (ans.answer) return { answer: ans.answer };
    }
    return { answer: "Market analytics are not available for that area. Try asking a general real estate question." };
  } catch (e) {
    return { error: e.message || "Market info failed" };
  }
}
